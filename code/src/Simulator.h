#ifndef SIMULATOR_H
#define SIMULATOR_H

#include "Apps.h"
#include <iostream>
#include <unordered_map>
#include <algorithm>
using namespace boost;

bool mycompare(std::pair<int,float> a, std::pair<int,float> b);

double pairing_function(int x, int y);

class Optimizer{
public:
	
	BaseApp* myapp;	
	distributed_graph* dag;
	std::vector<DataCenter*> DCs;
	
	/** edge distributions after vertex cut */
	//typedef std::pair<std::pair<int,int>, int> edge_loc;
	// std::vector<std::vector<std::pair<int,int> > > edge_distribution;
	std::vector<std::vector<int> > edge_distribution;
	std::vector<std::vector<int> > in_nbr_distribution;
	std::vector<std::vector<int> > out_nbr_distribution;
	
	/** for each vertex, stores an array of regions to be considered for replication*/
//	std::vector<std::vector<std::pair<int, float> > > RegionReduction();
	/** return the important vertex ids and their replication regions*/
//	std::vector<std::pair<int, std::vector<int> > >  VertexReduction();
	/** the heuristic which decides which vertex to replicate and where*/
//	void GraphOptimalReplicate(std::vector<std::pair<int, std::vector<int> > >);

	/** compared scheduling methods: random and greedy */
//	int ExpectedReplication(int vertex_id);
	void RandomReplication();
	/** heuristic in PowerGraph paper */
	void GreedyReplication();
	/** heuristic in PowerLyra paper */
	void HybridCut();	
	/** heterogeneity-aware partitioning in GraphH */
	void HPartition();
	/** return: the communication money cost and current wan usage for GrapH */
	std::pair<float,float> commCost();
	
	// ***************************** Heterogeneity-aware Partitioning ***************************** //
	/** Return the addtional gathering network traffic by adding a edge (src, tgt) to datacenter loc */
	float DeltaGatherTraffic(int src, int tgt, int loc, int iter){
		float delta = 0.0;
		//there exist a copy of tgt in datacenter loc
		if(std::find((*dag->g)[tgt].replica_location.begin(),(*dag->g)[tgt].replica_location.end(),loc) != 
			(*dag->g)[tgt].replica_location.end()){
			float gather_msg_tgt = 0;
			//find the number of local gather nbrs to tgt in datacenter loc
			std::vector<int> gather_nbrs = myapp->get_gather_nbrs(tgt,dag);
			std::vector<float> msg_container = std::vector<float>(gather_nbrs.size());
		// #pragma omp parallel for	    
			for(int i=0; i<gather_nbrs.size(); i++){
				// thread safety??
				if(std::find((*dag->g)[gather_nbrs[i]].replica_location.begin(),(*dag->g)[gather_nbrs[i]].replica_location.end(),loc) != 
					(*dag->g)[gather_nbrs[i]].replica_location.end()){
						msg_container[i] = myapp->msg_size; 
				}
				
			}
			for(int i=0; i<gather_nbrs.size(); i++)
				gather_msg_tgt += msg_container[i];
			//gather_msg_tgt *= myapp->red_rate;
			float aggregated_msg = (gather_msg_tgt + myapp->msg_size);// * myapp->red_rate ;
			delta = aggregated_msg - gather_msg_tgt;
		}else{
			delta = myapp->msg_size;
		}
		
		return delta;
	}
	/** assigning edges (src,dst) to different dcs based on the rules **/	
	void StreamEdgeAssignment();
	/** move the initial data location before edge assignments */
	void InputDataMovement();
	/** decide the placement of partitions generated by StreamEdgeAssignment() */
	void PartitionPlacement();
	/** edge migration from bottlenecked datacenter */
	void EdgeMigration();
	/** traffic-aware edge assignment, for one edge */
	std::pair<int,int> EdgeAssign(int src, int tgt, std::vector<int> notmoveto, std::vector<int> loads){
		std::vector<int> src_replicas = (*dag->g)[src].replica_location;
		std::vector<int> tgt_replicas = (*dag->g)[tgt].replica_location;
		std::vector<int> intersection(src_replicas.size()+tgt_replicas.size());
		std::vector<int>::iterator it;
		std::sort(src_replicas.begin(),src_replicas.end());
		std::sort(tgt_replicas.begin(),tgt_replicas.end());
		it = std::set_intersection(src_replicas.begin(), src_replicas.end(), tgt_replicas.begin(), tgt_replicas.end(), intersection.begin());
		intersection.resize(it-intersection.begin()); 
		// // permutation, in case edges all assigned to the same dc
		// std::srand ( unsigned ( std::time(0) ) );
		// std::random_shuffle ( intersection.begin(), intersection.end() );
		int dc_to_place = -1;
		int tag = -1; //
		float LARGE_FLOAT = 1e18;  
		if(intersection.size() > 0){
			tag = 0;
			float lowest_traffic = LARGE_FLOAT;
			float lowest_load = LARGE_FLOAT;
			for(int i=0; i< intersection.size(); i++){
				if(std::find(notmoveto.begin(),notmoveto.end(),intersection[i]) == notmoveto.end()){
					float delta_traffic = DeltaGatherTraffic(src,tgt,intersection[i],0);
					if(delta_traffic < lowest_traffic){ 
						lowest_traffic = delta_traffic;
						dc_to_place = intersection[i];						
					}else if(delta_traffic == lowest_traffic && loads[intersection[i]] < lowest_load){
						lowest_load = loads[intersection[i]];
						dc_to_place = intersection[i];
					}
				}				
			}
		}else if(src_replicas.size() > 0 && tgt_replicas.size() > 0){
			float lowest_traffic = LARGE_FLOAT;
			float lowest_load = LARGE_FLOAT;
			for(int i=0; i<src_replicas.size(); i++){				
				if(std::find(notmoveto.begin(),notmoveto.end(),src_replicas[i]) == notmoveto.end()){
					float delta_traffic = DeltaGatherTraffic(src,tgt,src_replicas[i],0);
					delta_traffic += myapp->msg_size; //msg size of tgt
					if(delta_traffic < lowest_traffic){
						lowest_traffic = delta_traffic;
						dc_to_place = src_replicas[i];
					}else if(delta_traffic == lowest_traffic && loads[src_replicas[i]] < lowest_load){
						lowest_load = loads[src_replicas[i]];
						dc_to_place = src_replicas[i];
					}
				}				
			}
			bool flag = false;
			for(int i=0; i<tgt_replicas.size(); i++){
				if(std::find(notmoveto.begin(),notmoveto.end(),tgt_replicas[i]) == notmoveto.end()){
					float delta_traffic = DeltaGatherTraffic(src,tgt,tgt_replicas[i],0);
					delta_traffic += myapp->msg_size; //msg size of src
					if(delta_traffic < lowest_traffic){
						lowest_traffic = delta_traffic;
						dc_to_place = tgt_replicas[i];
						flag = true;
					}else if(delta_traffic == lowest_traffic && loads[tgt_replicas[i]] < lowest_load){
						lowest_load = loads[tgt_replicas[i]];
						dc_to_place = tgt_replicas[i];
						flag = true;
					}
				}				
			}
			if(flag){
				//src is replicated 
				tag = 1;
				(*dag->g)[src].replica_location.push_back(dc_to_place);
			}else{
				tag = 2;
				(*dag->g)[tgt].replica_location.push_back(dc_to_place);
			}
		}else if(src_replicas.size() > 0 || tgt_replicas.size() > 0 ){
			std::vector<int> space = src_replicas.size()>0 ? src_replicas : tgt_replicas;
			float lowest_traffic = LARGE_FLOAT;
			float lowest_load = LARGE_FLOAT;
			for(int i=0; i<space.size(); i++){
				if(std::find(notmoveto.begin(),notmoveto.end(),space[i]) == notmoveto.end()){
					float delta_traffic = DeltaGatherTraffic(src,tgt,space[i],0);
					if(delta_traffic < lowest_traffic){
						lowest_traffic = delta_traffic;
						dc_to_place = space[i];
					}else if(delta_traffic == lowest_traffic && loads[space[i]] < lowest_load){
						lowest_load = loads[space[i]];
						dc_to_place = space[i];
					}
				}				
			}
			//update the replica_location 
			if(src_replicas.size()>0){
				//tgt is replicated
				tag = 2;
				(*dag->g)[tgt].replica_location.push_back(dc_to_place);
			}else{
				tag = 1;
				(*dag->g)[src].replica_location.push_back(dc_to_place);
			}
		}else{
			//iterate from all available datacenters
			float lowest_traffic = LARGE_FLOAT;
			float lowest_load = LARGE_FLOAT;
			for(int i=0; i<DCs.size(); i++){
				if(std::find(notmoveto.begin(),notmoveto.end(),i) == notmoveto.end()){
					float delta_traffic = DeltaGatherTraffic(src,tgt,i,0);
					if(delta_traffic < lowest_traffic){
						lowest_traffic = delta_traffic;
						dc_to_place = i;
					}else if(delta_traffic == lowest_traffic && loads[i] < lowest_load){
						lowest_load = loads[i];
						dc_to_place = i;
					}
				}
			}
			tag = 3;
			//update the replica_location 
			(*dag->g)[tgt].replica_location.push_back(dc_to_place);
			(*dag->g)[src].replica_location.push_back(dc_to_place);
		}
		return std::pair<int,int>(dc_to_place,tag);
	}
	/** network-aware edge migration, for a group of edges */
	std::pair<int,std::vector<int> > EdgeMigrate(std::vector<int > connected_edges, std::vector<int> notmoveto, float curtime){
		std::pair<int,std::vector<int> > results;		
		results.first = -1;
		std::vector<float> datas = std::vector<float>(DCs.size()*4,0.0);	
		for(int dc=0; dc<DCs.size(); dc++){
			if(std::find(notmoveto.begin(),notmoveto.end(), dc) != notmoveto.end())
				continue;
			// context recovery
			for(int dc =0; dc<DCs.size(); dc++){
				datas[dc*4] = DCs[dc]->g_upload_data;
				datas[dc*4+1] = DCs[dc]->g_dnload_data;
				datas[dc*4+2] = DCs[dc]->a_upload_data;
				datas[dc*4+3] = DCs[dc]->a_dnload_data;
			}		
			std::vector<int> curr_result;
			for(int i=0; i<connected_edges.size(); i++){ //migrate all edges to the same dc	
				int tag = -1;
				int src = source(dag->random_access_edges[connected_edges[i]],*dag->g);
				int tgt = target(dag->random_access_edges[connected_edges[i]],*dag->g);
				std::vector<int> src_replicas = (*dag->g)[src].replica_location;
				std::vector<int> tgt_replicas = (*dag->g)[tgt].replica_location;
				bool insrc = (std::find(src_replicas.begin(),src_replicas.end(),dc) != src_replicas.end());
				bool intgt = (std::find(tgt_replicas.begin(),tgt_replicas.end(),dc) != tgt_replicas.end());
				if(insrc && intgt){
					if((*dag->g)[src].master_location != dc && myapp->BiDirected){
						datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
					}						
					if((*dag->g)[tgt].master_location != dc){
						datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
					}	
					tag = 0;
				}else if(insrc){
					//replicate tgt
					if((*dag->g)[src].master_location != dc && myapp->BiDirected)
						datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
					//add a tgt mirror: increase g_upload_data and a_dnload_data											
					datas[dc*4] += myapp->msg_size;	
					datas[dc*4+3] += myapp->msg_size;	
					datas[(*dag->g)[tgt].master_location*4+1] += myapp->msg_size;
					datas[(*dag->g)[tgt].master_location*4+2] += myapp->msg_size;	
					tag = 1;
				}else if(intgt){
					//replicate src
					if((*dag->g)[tgt].master_location != dc)
						datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
					//add a src mirror: increase g_upload_data and a_dnload_data
					if(myapp->BiDirected){
						datas[dc*4] += myapp->msg_size;									
						datas[(*dag->g)[src].master_location*4+1] += myapp->msg_size;
					}
					datas[dc*4+3] += myapp->msg_size;	
					datas[(*dag->g)[src].master_location*4+2] += myapp->msg_size;						
					tag = 2;
				}else{
					//add src mirror, tgt mirror
					if(myapp->BiDirected){
						datas[dc*4] += myapp->msg_size;// * myapp->red_rate;					
						datas[(*dag->g)[src].master_location*4+1] += myapp->msg_size;
					}
					datas[dc*4+3] += myapp->msg_size;	
					datas[(*dag->g)[src].master_location*4+2] += myapp->msg_size;
					datas[dc*4] += myapp->msg_size;	
					datas[dc*4+3] += myapp->msg_size;	
					datas[(*dag->g)[tgt].master_location*4+1] += myapp->msg_size;
					datas[(*dag->g)[tgt].master_location*4+2] += myapp->msg_size;	
					tag = 3;
				}		
				curr_result.push_back(tag);
			}//endfor each connected edge
			float tmptime = EstimateTransferTime(datas);
			if(tmptime < curtime){
				curtime = tmptime;
				results.first = dc; 
				results.second = curr_result;
			}
		}
		return results;
	}
	/** network-aware edge migration, for one edge */
	std::pair<std::pair<int,int>,float> EdgeMigrate(int src, int tgt, std::vector<int> notmoveto, float curtime){
		//btlink: 0=up, 1=down		
		int dc_to_place = -1;
		int tag = -1;
		std::vector<int> src_replicas = (*dag->g)[src].replica_location;
		std::vector<int> tgt_replicas = (*dag->g)[tgt].replica_location;
		std::vector<float> datas = std::vector<float>(DCs.size()*4,0.0);		
		for(int dc =0; dc<DCs.size(); dc++){
			if(std::find(notmoveto.begin(),notmoveto.end(), dc) != notmoveto.end())
				continue;
			// context recovery
			for(int dc =0; dc<DCs.size(); dc++){
				datas[dc*4] = DCs[dc]->g_upload_data;
				datas[dc*4+1] = DCs[dc]->g_dnload_data;
				datas[dc*4+2] = DCs[dc]->a_upload_data;
				datas[dc*4+3] = DCs[dc]->a_dnload_data;
			}		
			bool insrc = (std::find(src_replicas.begin(),src_replicas.end(),dc) != src_replicas.end());
			bool intgt = (std::find(tgt_replicas.begin(),tgt_replicas.end(),dc) != tgt_replicas.end());
			if(insrc && intgt){
				if((*dag->g)[src].master_location != dc && myapp->BiDirected){
					datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
				}						
				if((*dag->g)[tgt].master_location != dc){
					datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
				}	
				
				float tmptime = EstimateTransferTime(datas);
				if(tmptime < curtime){
					curtime = tmptime;
					dc_to_place = dc;
					tag = 0;
				}		
			}else if(insrc){
				//replicate tgt
				if((*dag->g)[src].master_location != dc && myapp->BiDirected)
					datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
				//add a tgt mirror: increase g_upload_data and a_dnload_data											
				datas[dc*4] += myapp->msg_size;	
				datas[dc*4+3] += myapp->msg_size;	
				datas[(*dag->g)[tgt].master_location*4+1] += myapp->msg_size;
				datas[(*dag->g)[tgt].master_location*4+2] += myapp->msg_size;				
				
				float tmptime = EstimateTransferTime(datas);
				if(tmptime < curtime){
					curtime = tmptime;
					dc_to_place = dc;
					tag = 2;
				}				
			}else if(intgt){
				//replicate src
				if((*dag->g)[tgt].master_location != dc)
					datas[dc*4] += myapp->msg_size;// * myapp->red_rate;
				//add a src mirror: increase g_upload_data and a_dnload_data
				if(myapp->BiDirected){
					datas[dc*4] += myapp->msg_size;									
					datas[(*dag->g)[src].master_location*4+1] += myapp->msg_size;
				}
				datas[dc*4+3] += myapp->msg_size;	
				datas[(*dag->g)[src].master_location*4+2] += myapp->msg_size;
				
				float tmptime = EstimateTransferTime(datas);
				if(tmptime < curtime){
					curtime = tmptime;
					dc_to_place = dc;
					tag = 1;
				}				
			}else{
				//add src mirror, tgt mirror
				if(myapp->BiDirected){
					datas[dc*4] += myapp->msg_size;// * myapp->red_rate;					
					datas[(*dag->g)[src].master_location*4+1] += myapp->msg_size;
				}
				datas[dc*4+3] += myapp->msg_size;	
				datas[(*dag->g)[src].master_location*4+2] += myapp->msg_size;
				datas[dc*4] += myapp->msg_size;	
				datas[dc*4+3] += myapp->msg_size;	
				datas[(*dag->g)[tgt].master_location*4+1] += myapp->msg_size;
				datas[(*dag->g)[tgt].master_location*4+2] += myapp->msg_size;	
				
				float tmptime = EstimateTransferTime(datas);
				if(tmptime < curtime){
					curtime = tmptime;
					dc_to_place = dc;
					tag = 3;
				}				
			}			
		}//endfor each dc	
				
		return std::pair<std::pair<int,int>,float>(std::pair<int,int>(dc_to_place,tag),curtime);
	}
	/** estimate the data transfer time	given a partition placement */
	float EstimateTransferTime(){
		float gather_max_time = 0.0;
		float apply_max_time = 0.0;
		for(int dc=0; dc<DCs.size(); dc++){
			float g_upload_time = DCs[dc]->g_upload_data / DCs[dc]->upload_band;
			float g_dnload_time = DCs[dc]->g_dnload_data / DCs[dc]->download_band;
			float a_upload_time = DCs[dc]->a_upload_data / DCs[dc]->upload_band;
			float a_dnload_time = DCs[dc]->a_dnload_data / DCs[dc]->download_band;
			
			if(g_upload_time > gather_max_time){
				gather_max_time = g_upload_time;
			}
			if(g_dnload_time > gather_max_time){
				gather_max_time = g_dnload_time;
			}		
			if(a_upload_time > apply_max_time){
				apply_max_time = a_upload_time;
			}
			if(a_dnload_time > apply_max_time){
				apply_max_time = a_dnload_time;
			}
		}
		
		return gather_max_time + apply_max_time;
	}
	float EstimateTransferTime(std::vector<float> datas){
		float gather_max_time = 0.0;
		float apply_max_time = 0.0;
		for(int dc=0; dc<DCs.size(); dc++){
			float g_upload_time = datas[dc*4] / DCs[dc]->upload_band;
			float g_dnload_time = datas[dc*4+1] / DCs[dc]->download_band;
			float a_upload_time = datas[dc*4+2] / DCs[dc]->upload_band;
			float a_dnload_time = datas[dc*4+3] / DCs[dc]->download_band;
			
			if(g_upload_time > gather_max_time){
				gather_max_time = g_upload_time;
			}
			if(g_dnload_time > gather_max_time){
				gather_max_time = g_dnload_time;
			}		
			if(a_upload_time > apply_max_time){
				apply_max_time = a_upload_time;
			}
			if(a_dnload_time > apply_max_time){
				apply_max_time = a_dnload_time;
			}
		}
		
		return gather_max_time + apply_max_time;
	}
	/** find the best dc to switch the btlneck */
	std::pair<float,int> EstimateGain(int btlneck, std::vector<int> options){
		int dc_to_switch = -1;
		float bestgain = 0.0;
		float cur_time = EstimateTransferTime();
		for(int di=0; di < options.size(); di++){
			if(options[di] != btlneck){
				//float cur_time_d = EstimateTransferTime(options[di]);				
				//save context
				float orig_up = DCs[btlneck]->upload_band;
				float orig_dn = DCs[btlneck]->download_band;
				float swit_up = DCs[options[di]]->upload_band;
				float swit_dn = DCs[options[di]]->download_band;
				//pretend to switch btlneck with options[di]
				DCs[btlneck]->upload_band = swit_up;
				DCs[btlneck]->download_band = swit_dn;
				DCs[options[di]]->upload_band = orig_up;
				DCs[options[di]]->download_band = orig_dn;
				//calculate the gain
				//float new_time_b = EstimateTransferTime(btlneck);
				//float new_time_d = EstimateTransferTime(options[di]);	
				//float cur_time = cur_time_b > cur_time_d ? cur_time_b : cur_time_d;
				//float new_time = new_time_b > new_time_d ? new_time_b : new_time_d;
				float new_time = EstimateTransferTime();
				float switch_cost = DCs[btlneck]->data_size + DCs[options[di]]->data_size;
				float gain = (cur_time-new_time)/switch_cost;
				if(gain > bestgain){
					bestgain = gain;
					dc_to_switch = options[di];
				}
				//copy back the context
				DCs[btlneck]->upload_band = orig_up;
				DCs[btlneck]->download_band = orig_dn;
				DCs[options[di]]->upload_band = swit_up;
				DCs[options[di]]->download_band = swit_dn;
			}
		}		
		return std::pair<float,int>(bestgain,dc_to_switch);
	}
};

enum EngineType{
	synchronous,
	asynchronous,
	numofengine
};
	
 class GraphEngine{
	
public:
	EngineType type;
	int num_threads; //number of mpi threads
	BaseApp* myapp;	
	Optimizer* myopt;
	std::vector<DataCenter*> DCs;
	
	class Thread{
	public:
		distributed_graph* l_dag;
		int DC_loc_id;
		/* hash map from global vertex id to local vertex id*/
		std::unordered_map<int,int> vid2lvid;
		
		/* message pool */
		struct mpi_message{
			int src_thread;
			int tgt_thread;
			int src_l_vid;
			int tgt_l_vid;
			VertexData* msg_value;
			float msg_size;
			float transfer_time;
		};
		/* messages received and queued by the current thread */
		std::vector<mpi_message> messages;
	};
	
	std::vector<Thread* > Threads;
	
	GraphEngine(EngineType t, int n){
		type = t; num_threads = n; 		
	}
	 void Simulate(char*);
	

};
#endif
// class KMPClustering{
	// public:
	// DataCenter* DCs;
	// distributed_graph* dag;
	// BaseApp* myapp;
	// // if flag=0, clustering for vertices
	// // if flag=1, clustering for machines
	// int flag;
	// int K;
	
	// // the id can be for a vertex or a datacenter
	// typedef struct { int id; int group; } point_t;
 
	// double randf(double m)	{
		// return distributed_graph::rnd_generator(0,m);
	// } 

	// inline double dist2(point_t a, point_t b){
		// float distance = 0.0;
		// if(flag == 0){
			// // clustering for vertices
			// // if there is an edge between the two vertices
			// // distance equals to the data traffic
			// std::vector<int> in_nbrs = dag->get_in_nbrs(a.id);
			// std::vector<int> out_nbrs = dag->get_out_nbrs(a.id);
			// if(std::find(in_nbrs.begin(),in_nbrs.end(),b.id)!=in_nbrs.end()){
				// distance += myapp->msg_size;
			// } 
			// if(	std::find(out_nbrs.begin(),out_nbrs.end(),b.id)!=out_nbrs.end()&& myapp->BiDirected){
				// distance += myapp->msg_size; 
			// }
			// distance = 1.0/distance;
		// }else if(flag == 1){
			// // clustering for machines
			// // distance equals to the bandwidth
		// }else {
			// printf("clustering flag has to be 0 for vertices or 1 for machines\n");
			// exit(1);
		// }
		// return distance;
	// }
	// /** K-Means++ algorithm to cluster vertices (for InputDataMovement) or machines (for HPartition)*/
	// KMPClustering(int k, int f){ K = k; flag = f; }
// };
